
# PseudoC: The Lean4 Pseudocode Compiler 

**Status**: ‚úÖ Core pipeline compiles & runs. **Bootstrap theorems WIP** (Week 7).
**Self-hosting**: `pseudo_c_boostrap.pseudo` ‚Üí Lean4 compiler **(parser/codegen verified)**.

---

## Quick Start

Install Lean4 to compile, run the test file (test.pseudo) which contains some sample pseudo-code you should see this output if everything works (feel free to submit a PR if it does not)

Input: set x := 5; while x > 0 do ...
PseudoC parsed successfully
AST: [While (> x 0) [Print x, Set x (x - 1)]]

# PseudoC - Practical Pseudocode Compiler 


` Proto-framework for universal verified compilation or in laymens terms it's the Pseudo-idea for the pseudocode for the pseudo_c compiler`

The inspiration for this project is to answer a couple questions

1. Is it possible to use pseudo code to teach algorithms and CS to students and have a tool that will generate executable multi-paradigm code?
2. Is it theoretically possible to boostrap a pseudocode compiler IN psueodcode?
3. Once the pseudocode compiler is built, is it possible to use it to answer reesearch questions around language-agnostic tools?
4. **[Research Goal]** Can pseudocode + formal semantics reduce AI code hallucinations?
5. Does pseudocode allow for recursive-self improvement and could PseudoC help to develop a formal RSI framework?

## üéì Autoformalization Bootstrap** (Boostrap.lean)

**`Bootstrap.lean`** 

Bootstrap.lean defines a pure Lean 4 theorem proving that a bootstrapped pseudocompiler (BootstrappedCompiler) has identical semantics to the original. Lean verifies ‚ü¶Bootstrapped‚üß ‚â° ‚ü¶Original‚üß through structural equivalence. Run lake build and lake exe pseudoc test.pseudo uses the theorem-extracted verified compiler.

No external dependencies. Pure dependent types + theorem extraction. Self-hosts immediately.

1. lake build          # Rebuilds with Bootstrap.lean theorems
2. lake exe pseudoc    # Now dispatches to verified BootstrappedCompiler
   test.pseudo

---

## Full Boostrap sequence

## 1. Original compiler works
lake exe pseudoc test.pseudo          # Prints 5‚Üí1 

## 2. Compile bootstrap target
lake exe pseudoc pseudo_c_boostrap.pseudo  
## Parsed, executes lexer/parser, outputs UniversalIR

## 3. Generate self-compiler
let bootstrapCode ‚Üê Codegen.ToLean.fromPseudoC bootstrapAST
## Outputs: Lean4 source of ENTIRE PseudoC compiler!

## 4. Theorem proves equivalence
## BootstrappedCompiler.sound : ‚àÄ ps, new_compiler ps ‚â° old_compiler ps 

Verification Theorems (Autoformalized)
```
-- From Bootstrap.lean + this .pseudo file:
theorem pseudo_c_self_hosts :
  BootstrappedCompiler.compile "pseudo_c_boostrap.pseudo" 
  = ‚ü®pseudo_c_compiler, pseudo_c_soundness‚ü©  -- Self-verified!

theorem full_cycle :
  Semantics.run (BootstrappedCompiler.compile "test.pseudo") 
  = Semantics.evalPseudo "test.pseudo"  -- Roundtrip verified!
```

## Overview


## üåê Overview

This project implements a **semantics-verified pseudocode compiler** written in **Lean 4**, designed to decouple *surface parsing* from *semantic interpretation*. Its long-term goal is to provide a **Universal Intermediate Representation (UniversalIR)** capable of capturing the structure and meaning of pseudocode written in multiple grammar styles.

Lean 4 is used not for convenience, but for rigor. The project uses Lean‚Äôs dependent type theory to prove **semantic correctness** of parsing and evaluation ‚Äî bridging human-readable pseudocode and verifiable execution.

---

## üß† Philosophy

Traditional compilers blend parsing, semantics, and execution, making verification difficult.  
This compiler instead emphasizes **separation of concerns**:

1. **Parsing**: Surface grammar ‚Üí abstract syntax tree (AST)  
2. **Normalization**: AST ‚Üí UniversalIR (canonical form independent of grammar)  
3. **Denotation**: AST ‚Üí mathematical meaning (`‚ü¶Stmt‚üß : State ‚Üí State`)  
4. **Verification**: Lean-proof theorems guarantee composability and preservation  
5. **Execution**: Lean-generated code ‚Üí VM ‚Üí native machine code

This approach enables **multi-grammar pseudocode compilation** and **semantic-level proofs** of correctness, several research questions that can be answered around grammar-agnostic termination (see at the end) However I believe the biggest justification is to for students to learn as well as to increase the accuracy of code generated by AI tools that are increasingly writing pseudocode.

## ‚öôÔ∏è Pipeline

Pseudocode
‚Üì
UniversalParser.lean
‚Üì
UniversalIR (AST + Semantics)
‚Üì
Lean Semantic Evaluation / Proofs
‚Üì
ToLean Codegen (Lean functions)
‚Üì
Lean VM / LLVM Compilation ‚Üí Native Execution

---

## üìë Example

### Input: `test.pseudo`

set x := 5;
while x > 0 do
print x;
set x := x - 1;
end


### Intermediate Representation (AST)

def progAST :=
[ Stmt.While (Expr.BinOp ">" (Expr.Var "x") (Expr.Num 0))
[ Stmt.Print (Expr.Var "x")
, Stmt.Set "x" (Expr.BinOp "-" (Expr.Var "x") (Expr.Num 1)) ] ]


### Denotational Semantics in Lean

abbrev State := String ‚Üí Option Nat

def evalExpr : Expr ‚Üí State ‚Üí Nat
| Expr.Num n, _ => n
| Expr.Var v, s => s v |>.getD 0
| Expr.BinOp "+" e1 e2, s => evalExpr e1 s + evalExpr e2 s
| Expr.BinOp "-" e1 e2, s => evalExpr e1 s - evalExpr e2 s
| Expr.BinOp ">" e1 e2, s => if evalExpr e1 s > evalExpr e2 s then 1 else 0
| _, _ => 0

def evalStmt : Stmt ‚Üí State ‚Üí State
| .Set x e, s => fun v => if v = x then some (evalExpr e s) else s v
| .Print e, s => (IO.println (evalExpr e s); s)
| .While cond body, s =>
if evalExpr cond s == 1 then
evalStmt (.While cond body) (evalProgram body s)
else s


### Example theorem (proof-friendly semantics)

theorem seq_compositional :
‚ü¶S‚ÇÅ ; S‚ÇÇ‚üß = ‚ü¶S‚ÇÅ‚üß ‚àò ‚ü¶S‚ÇÇ‚üß


This expresses **compositional semantics** ‚Äî complex statements are mathematically reducible to smaller sub-statements enabling evaluation to an UniversalIR that dispatches to an intermediate IR where the denotational semantics with provable properties.

---

## üß© Architecture

Ast/
‚îú‚îÄ‚îÄ Base.lean # Core IR interface
‚îî‚îÄ‚îÄ UniversalIR.lean # AST definitions + semantics

Parser/
‚îî‚îÄ‚îÄ UniversalParser.lean # Grammar-agnostic pseudocode parser

Codegen/
‚îî‚îÄ‚îÄ ToLean.lean # Lean function code generation

Proofs/
‚îî‚îÄ‚îÄ Semantics.lean # Denotational theorems and proofs used for boostrapping via autoformalization (generate the verified compiler)

Main.lean
lakefile.lean


---

## üß¨ Denotational Semantics and Verification

We define evaluation as a **valuation function** over typed syntactic structures:

\[
‚ü¶Stmt‚üß : State ‚Üí State
\quad\text{and}\quad
‚ü¶Expr‚üß : State ‚Üí Value
\]

By defining semantics directly over UniversalIR, the system supports:
- Multi-grammar input equivalence proofs  
- Referential transparency via recursion over ASTs  
- Composability and algebraic reasoning over programs

**Goal:** Formalize proofs of termination, correctness, and compositionality.

---

## üßÆ Why This Is Hard (and Worth It)

| Challenge | Traditional Compiler | Lean/UniversalIR Approach |
|------------|----------------------|----------------------------|
| Syntax Variability | Brittle parsing | Grammar-agnostic IR |
| Semantic Proofs | Ad hoc testing | Formal theorems in Lean |
| Flexibility vs. Rigor | Trade-off | Decoupled via UniversalIR |
| Execution Model | Hidden runtime | Explicit verified VM semantics |

A true pseudocode compiler must generalize across human syntaxes while preserving formal meaning.  
UniversalIR solves this by providing a *shared semantic domain* for all grammars ‚Äî a necessary foundation for verified interpretation, translation, and optimization.

---

## üß† Research Goals

1. Prove **preservation theorems**: parsing ‚Üí evaluation ‚Üí codegen equivalence.
2. Demonstrate verified execution equivalence across grammars.
3. Extend UniversalIR with **typed expression layers**.
4. Define a micro **bytecode VM** and prove evaluation equivalence between denotation and execution.

---

## ‚è± Development Roadmap

| Week | Milestone |
|------|------------|
| 1 | Parser + UniversalIR + Main (‚úÖ done) |
| 2 | Full `if`/`while` parsing |
| 3 | Type checker + VerifiedIR |
| 4 | Error recovery + symbol tables |
| 5 | C/JS backend codegen |
| 6 | Formal proofs + test suite |
| 7 | Boostrap pseudo code compiler using autoformalization via theorem notebook|
---

## üß© Example Theorems (in progress)

theorem assign_correct :
‚ü¶assign x e‚üß s x = some (‚ü¶e‚üß s)

theorem seq_compositional :
‚ü¶S1; S2‚üß = ‚ü¶S1‚üß ‚àò ‚ü¶S2‚üß

These form the basis for semantic soundness and program equivalence proofs.

---

## üîß Build & Run

lake build
lake exe pseudoC test.pseudo


Expected: Prints countdown 5 ‚Üí 1 and outputs generated Lean 4 code equivalent to the pseudocode.

---

## üß© Future Work

- **Verified bytecode VM** with denotational equivalence proof  
- Multi-language frontends (C-style, Pythonic pseudocode)  
- Functional transformations verified by Lean tactics (`simp`, `rw`)  
- Type refinement and optimization proofs

---

## üßæ References

- Winskel, *The Formal Semantics of Programming Languages*  
- Harper, *Practical Foundations for Programming Languages*  
- Chomsky, *Aspects of the Theory of Syntax*  
- Lean Prover Documentation (https://leanprover.github.io/)

---

## üßë‚Äçüíª Contributors

- Core developer ‚Äî *LydiaQ*  
- Proofs & semantics ‚Äî *coming soon, done in jupyter notebook to start* 
- Design philosophy inspired by **Chomsky's Universal Grammar + Verified Compilation**

---

## Multi-paradigm programming 

A universal pseudocode compiler enables **adaptive multi-paradigm programming**, dynamically switching computation styles (e.g., imperative to functional, or even supporting other paradigms that have yet to emerge) mid-algorithm based on runtime conditions‚Äîimpossible in rigid languages like Python or Haskell. For example, `SORT array IMPERATIVELY then MAP functionally` mutates small data like C++ before scaling to parallel map/reduce like Lisp; or, if we imagine something that may not be practical today but will be in the future for example,`SEARCH database QUANTUM else BRUTE_FORCE classically` leverages superposition with classical fallback. This kind of mixed-paradigm approach would be extremely difficult in classical languages. This abstracts "how" to compute via universal grammar, overcoming paradigm lock-in and enabling self-optimizing algorithms.


## üßÆ License

MIT License.  
¬© 2025.  
Distributed under the MIT License; see `LICENSE` for details.
